// 하노이의 탑은 유명한 재귀 문제의 예시이다.

// 원판이 하나 있을때는 원판을 어떻게 옮겨야 하는가?
// 당연히 1번이다.

// 원판이 2개 있을때는 원판을 어떻게 옮겨야 하는가?
// 먼저 위에 원판 하나를 2번으로 옮기고, 맨 아래 원판을 3번으로 옮긴 뒤,
// 2번에 있던 원판 하나를 3번으로 옮긴다.

// 원판이 3개 있을때는 원판을 어떻게 옮겨야 하는가?
// 먼저 위에 있던 원판 2개를 2번으로 옮기고, 맨 아래 원판을 3번으로 옮긴 뒤,
// 2번에 있던 원판들을 3번으로 옮긴다.

// 이것을 일반화해보면, 원판이 N개 있을 때에는 원판을 어떻게 옮겨야 하는가?
// 먼저 위에 있던 원판 N - 1개를 2번으로 옮기고, 맨 아래 원판을 3번으로 옮긴 뒤,
// 2번에 있던 원판들을 3번으로 옮긴다.

// 이때 횟수의 관계식은 (N개의 원판을 옮길 때 필요한 횟수) == (N - 1개의 원판을 옮길 때 필요한 횟수) * 2 + 1로,
// (1개의 원판을 옮길 때 필요한 횟수) == 1이므로
// 일반식은 2^N - 1이다.

// 이때 원판을 옮기는 과정을 관찰해보면, 2개 이상의 원판을 옮길 때
// 처음에 원판들이 있던 장소에서 제 3의 장소로 원판 N - 1개를 먼저 옮기고,
// 1개의 원판을 옮겨야 하는 장소로 옮기고,
// 제 3의 장소에서 원판 N - 1개를 옮겨야 할 장소로 옮긴다.

// 이때 처음 장소를 a, 옮겨야 할 장소를 b라고 하면,
// 제 3의 장소를 6 - (a + b)로 나타낼 수 있다.

#include <iostream>
#include <cmath> // powl
using namespace std;

void hanoi(int from, int to, int N)
{
    if (N == 1)
    {
        cout << from << " " << to << '\n';
        return;
    }

    hanoi(from, 6 - from - to, N - 1);
    hanoi(from, to, 1);
    hanoi(6 - from - to, to, N - 1);
}

int main()
{
    size_t K;
    cin >> K;

    // 2^K - 1을 int형으로 표시한다.
    cout << (int)pow(2, K) - 1 << '\n';
    hanoi(1, 3, K);
}